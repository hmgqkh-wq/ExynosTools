#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

// BC4: single-channel with BC3-like interpolation.
// Signed/unsigned choice: use PC.scale100==200 to select SNORM fast-path (cheap branch outside hot loop).
float chan_interp(uint c0, uint c1, uint idx, bool isSigned) {
    float C0 = isSigned ? snormN(c0, 8) : float(c0) / 255.0;
    float C1 = isSigned ? snormN(c1, 8) : float(c1) / 255.0;
    if (c0 > c1) {
        if (idx == 0u) return C0;
        if (idx == 1u) return C1;
        return ((8.0 - float(idx)) * C0 + (float(idx) - 1.0) * C1) / 7.0;
    } else {
        if (idx == 0u) return C0;
        if (idx == 1u) return C1;
        if (idx == 6u) return isSigned ? -1.0 : 0.0;
        if (idx == 7u) return 1.0;
        return ((6.0 - float(idx)) * C0 + (float(idx) - 1.0) * C1) / 5.0;
    }
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    uint c0c1 = bc_words[bi * 2u + 0u];
    uint i0   = bc_words[bi * 2u + 1u];

    uint c0 = c0c1 & 0xffu;
    uint c1 = (c0c1 >> 8) & 0xffu;
    uint64_t idx64 = uint64_t(i0); // 48 bits used

    bool isSigned = (PC.scale100 == 200u);

    for (uint t = 0u; t < 16u; ++t) {
        uint idx = uint((idx64 >> (t * 3u)) & 7u);
        float R = chan_interp(c0, c1, idx, isSigned);
        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(R, R, R, 1.0));
    }
}
