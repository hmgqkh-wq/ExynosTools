#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

// BC1: RGB only (opaque or 1-bit alpha via "transparent" when c0 <= c1).
// Input layout: 2 uints per block: endpoints(32-bit), indices(32-bit).
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer { uint data[]; } inputBuffer;
layout(set = 0, binding = 1, rgba8) uniform image2D outputImage;

void main()
{
    ivec2 b = ivec2(gl_GlobalInvocationID.xy);
    ivec2 base = b * 4;
    ivec2 dim = imageSize(outputImage);
    if (base.x >= dim.x || base.y >= dim.y) return;

    int blocksX = (dim.x + 3) >> 2;
    int blockIndex = b.y * blocksX + b.x;
    int d = blockIndex * 2;

    uint endpoints32 = inputBuffer.data[d + 0];
    uint indices32   = inputBuffer.data[d + 1];

    // endpoints packed: low 16 = C0, high 16 = C1
    uvec2 endpoints = uvec2(endpoints32 & 0xFFFFu, (endpoints32 >> 16) & 0xFFFFu);
    vec3 pal[4];
    bool opaque;
    bc1Palette(endpoints, pal, opaque);

    for (uint ty=0u; ty<4u; ++ty)
    for (uint tx=0u; tx<4u; ++tx) {
        uint t = ty*4u + tx;
        uint i = idx2(indices32, t);
        vec4 outc;
        if (!opaque && i == 3u) {
            outc = vec4(0.0,0.0,0.0,0.0); // transparent
        } else {
            outc = vec4(pal[i], 1.0);
        }
        ivec2 p = base + ivec2(int(tx), int(ty));
        if (p.x < dim.x && p.y < dim.y) imageStore(outputImage, p, outc);
    }
}
