#version 450
// BC1 decoder using 32-bit word loads and byte extraction (no uint64_t)
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rgba8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push {
    uint srcOffset; // byte offset within buffer
    uint srcSize;   // size in bytes
    uint width;
    uint height;
} pc;

// Read a byte from srcBuf at absolute byte offset (little-endian)
uint readByte(uint byteOffset) {
    uint wordIndex = byteOffset >> 2;        // /4
    uint shift     = (byteOffset & 3u) * 8u; // %4 * 8
    uint word      = srcBuf.data[wordIndex];
    return (word >> shift) & 0xFFu;
}

// Read little-endian 16-bit at byte offset
uint readLE16(uint byteOffset) {
    uint b0 = readByte(byteOffset + 0u);
    uint b1 = readByte(byteOffset + 1u);
    return (b1 << 8u) | b0;
}

// Read little-endian 32-bit at byte offset
uint readLE32(uint byteOffset) {
    uint b0 = readByte(byteOffset + 0u);
    uint b1 = readByte(byteOffset + 1u);
    uint b2 = readByte(byteOffset + 2u);
    uint b3 = readByte(byteOffset + 3u);
    return (b3 << 24u) | (b2 << 16u) | (b1 << 8u) | b0;
}

uvec3 expand565(uint v) {
    uint r5 = (v >> 11u) & 0x1Fu;
    uint g6 = (v >> 5u)  & 0x3Fu;
    uint b5 = (v)        & 0x1Fu;
    return uvec3(r5 * 255u / 31u, g6 * 255u / 63u, b5 * 255u / 31u);
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    // Each BC1 block encodes 4x4 pixels (8 bytes)
    uint block_x = gx >> 2; // /4
    uint block_y = gy >> 2; // /4
    uint blocks_per_row = (pc.width + 3u) >> 2;
    uint block_index    = block_y * blocks_per_row + block_x;
    uint base           = pc.srcOffset + block_index * 8u;

    // Block layout: [c0 (LE16)] [c1 (LE16)] [index (LE32)]
    uint c0 = readLE16(base + 0u);
    uint c1 = readLE16(base + 2u);
    uint lut = readLE32(base + 4u);

    uvec3 col0 = expand565(c0);
    uvec3 col1 = expand565(c1);

    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pixel_index = py * 4u + px;
    uint code = (lut >> (pixel_index * 2u)) & 0x3u;

    uvec4 outColor;
    if (c0 > c1) {
        if (code == 0u)       outColor = uvec4(col0, 255u);
        else if (code == 1u)  outColor = uvec4(col1, 255u);
        else if (code == 2u)  outColor = uvec4((2u*col0 + col1)/3u, 255u);
        else                  outColor = uvec4((col0 + 2u*col1)/3u, 255u);
    } else {
        if (code == 0u)       outColor = uvec4(col0, 255u);
        else if (code == 1u)  outColor = uvec4(col1, 255u);
        else if (code == 2u)  outColor = uvec4((col0 + col1)/2u, 255u);
        else                  outColor = uvec4(0u, 0u, 0u, 0u);
    }

    imageStore(dstImg, ivec2(gx, gy), vec4(outColor) / 255.0);
}
