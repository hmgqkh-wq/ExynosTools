#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;  // Optimized for RDNA3 cache

layout(set = 0, binding = 0) buffer InputBuffer {
    uint data[];
} inputBuffer;

layout(set = 0, binding = 1, rgba8) uniform image2D outputImage;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy) * 4;  // Process 4x4 block
    uint blockIndex = (gl_GlobalInvocationID.y * (imageSize(outputImage).x / 4) + gl_GlobalInvocationID.x) * 2;  // 8 bytes per block

    uint lowColor = inputBuffer.data[blockIndex];
    uint highColor = inputBuffer.data[blockIndex + 1];

    vec4 color0 = unpackColor(lowColor);
    vec4 color1 = unpackColor(highColor);

    half4 hcolor0 = half4(color0);  // Use half for speed
    half4 hcolor1 = half4(color1);

    // Unroll interpolation
    half4 colors[4];
    colors[0] = hcolor0;
    colors[1] = hcolor1;
    colors[2] = hcolor0 * (2.0h / 3.0h) + hcolor1 * (1.0h / 3.0h);
    colors[3] = hcolor0 * (1.0h / 3.0h) + hcolor1 * (2.0h / 3.0h);

    uint indices = inputBuffer.data[blockIndex + 2];

    // Unroll pixel write with min/max to reduce branches
    for (uint y = 0u; y < 4u; y++) {  // Unrolled
        for (uint x = 0u; x < 4u; x++) {  // Unrolled
            uint idx = (indices >> ((y * 4 + x) * 2)) & 0x3;
            imageStore(outputImage, coord + ivec2(x, y), vec4(colors[idx]));
        }
    }
}
