#version 450
// BC5 dual-channel (two BC4 streams) simplified implementation
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rg8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push { uint srcOffset; uint srcSize; uint width; uint height; } pc;

float decode_channel(uint64_t block, uint idx) {
    uint index = (block >> (idx * 3u)) & 0x7u;
    return float(index) / 7.0;
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    uint block_x = gx / 4u;
    uint block_y = gy / 4u;
    uint blocks_per_row = (pc.width + 3u) / 4u;
    uint block_index = block_y * blocks_per_row + block_x;

    // BC5 stores two BC4 blocks sequentially (16 bytes)
    uint byte_offset = pc.srcOffset + block_index * 16u;
    uint word_index = byte_offset / 4u;

    uint w0 = srcBuf.data[word_index];
    uint w1 = srcBuf.data[word_index + 1u];
    uint w2 = srcBuf.data[word_index + 2u];
    uint w3 = srcBuf.data[word_index + 3u];

    uint64_t ch0 = (uint64_t(w1) << 32) | uint64_t(w0);
    uint64_t ch1 = (uint64_t(w3) << 32) | uint64_t(w2);

    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pixel_index = py * 4u + px;

    float v0 = decode_channel(ch0, pixel_index);
    float v1 = decode_channel(ch1, pixel_index);

    imageStore(dstImg, ivec2(gx, gy), vec4(v0, v1, 0.0, 1.0));
}
