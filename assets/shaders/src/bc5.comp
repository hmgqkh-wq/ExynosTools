#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

// BC5: two BC4 blocks for R and G. 4 uints per block: epR, idxR, epG, idxG.
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer { uint data[]; } inputBuffer;
layout(set = 0, binding = 1, rg32f) uniform image2D outputImage;

void main()
{
    ivec2 b = ivec2(gl_GlobalInvocationID.xy);
    ivec2 base = b * 4;
    ivec2 dim = imageSize(outputImage);
    if (base.x >= dim.x || base.y >= dim.y) return;

    int blocksX = (dim.x + 3) >> 2;
    uint blockIndex = uint(b.y * blocksX + b.x);
    uint d = blockIndex * 4u;

    uint epR  = inputBuffer.data[d + 0u];
    uint idxR = inputBuffer.data[d + 1u];
    uint epG  = inputBuffer.data[d + 2u];
    uint idxG = inputBuffer.data[d + 3u];

    float r0 = norm8(epR & 0xFFu);
    float r1 = norm8((epR >> 8) & 0xFFu);
    float g0 = norm8(epG & 0xFFu);
    float g1 = norm8((epG >> 8) & 0xFFu);

    float R[8]; float G[8];
    alpha8(r0, r1, R);
    alpha8(g0, g1, G);

    for (uint t=0u; t<16u; ++t) {
        uint ri = idx3(idxR, t);
        uint gi = idx3(idxG, t);
        vec2 rg = vec2(R[ri], G[gi]);

        ivec2 p = base + ivec2(int(t % 4u), int(t / 4u));
        if (p.x < dim.x && p.y < dim.y) imageStore(outputImage, p, vec4(rg,0.0,0.0));
    }
}
