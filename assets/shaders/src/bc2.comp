#version 450
// BC2 decoder: explicit 4-bit alpha + BC1 color (no uint64_t)
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rgba8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push { uint srcOffset; uint srcSize; uint width; uint height; } pc;

uint readByte(uint byteOffset) {
    uint wordIndex = byteOffset >> 2;
    uint shift     = (byteOffset & 3u) * 8u;
    uint word      = srcBuf.data[wordIndex];
    return (word >> shift) & 0xFFu;
}
uint readLE16(uint byteOffset) {
    uint b0 = readByte(byteOffset + 0u);
    uint b1 = readByte(byteOffset + 1u);
    return (b1 << 8u) | b0;
}
uint readLE32(uint byteOffset) {
    uint b0 = readByte(byteOffset + 0u);
    uint b1 = readByte(byteOffset + 1u);
    uint b2 = readByte(byteOffset + 2u);
    uint b3 = readByte(byteOffset + 3u);
    return (b3 << 24u) | (b2 << 16u) | (b1 << 8u) | b0;
}
uvec3 expand565(uint v) {
    uint r5 = (v >> 11u) & 0x1Fu;
    uint g6 = (v >> 5u)  & 0x3Fu;
    uint b5 = (v)        & 0x1Fu;
    return uvec3(r5 * 255u / 31u, g6 * 255u / 63u, b5 * 255u / 31u);
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    uint block_x = gx >> 2;
    uint block_y = gy >> 2;
    uint blocks_per_row = (pc.width + 3u) >> 2;
    uint block_index    = block_y * blocks_per_row + block_x;
    uint base           = pc.srcOffset + block_index * 16u;

    // First 8 bytes: alpha (16 x 4-bit values)
    // Next 8 bytes: color (BC1)
    uint alphaWord0 = readLE32(base + 0u);
    uint alphaWord1 = readLE32(base + 4u);
    uint c0         = readLE16(base + 8u);
    uint c1         = readLE16(base + 10u);
    uint lut        = readLE32(base + 12u);

    uvec3 col0 = expand565(c0);
    uvec3 col1 = expand565(c1);

    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pixel_index = py * 4u + px;

    // alpha: 4 bits per pixel, little-endian packed
    uint alpha4;
    if (pixel_index < 8u)
        alpha4 = (alphaWord0 >> (pixel_index * 4u)) & 0xFu;
    else
        alpha4 = (alphaWord1 >> ((pixel_index - 8u) * 4u)) & 0xFu;
    uint alpha8 = (alpha4 * 255u) / 15u;

    uint code = (lut >> (pixel_index * 2u)) & 0x3u;

    uvec3 rgb;
    if (c0 > c1) {
        if (code == 0u)       rgb = col0;
        else if (code == 1u)  rgb = col1;
        else if (code == 2u)  rgb = (2u*col0 + col1)/3u;
        else                  rgb = (col0 + 2u*col1)/3u;
    } else {
        if (code == 0u)       rgb = col0;
        else if (code == 1u)  rgb = col1;
        else if (code == 2u)  rgb = (col0 + col1)/2u;
        else                  rgb = uvec3(0u);
    }

    imageStore(dstImg, ivec2(gx, gy), vec4(vec3(rgb) / 255.0, float(alpha8) / 255.0));
}
