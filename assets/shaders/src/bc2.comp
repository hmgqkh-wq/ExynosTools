#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

// BC2: RGB from BC1-like endpoints+indices, alpha from 4-bit explicit per texel.
// Input: 4 uints per block: endpoints, rgbIndices, alpha0..alpha3 packed (16 4-bit nibbles).
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer { uint data[]; } inputBuffer;
layout(set = 0, binding = 1, rgba8) uniform image2D outputImage;

void main()
{
    ivec2 b = ivec2(gl_GlobalInvocationID.xy);
    ivec2 base = b * 4;
    ivec2 dim = imageSize(outputImage);
    if (base.x >= dim.x || base.y >= dim.y) return;

    int blocksX = (dim.x + 3) >> 2;
    int blockIndex = b.y * blocksX + b.x;
    int d = blockIndex * 4;

    uint endpoints32 = inputBuffer.data[d + 0];
    uint indices32   = inputBuffer.data[d + 1];
    uint alpha0      = inputBuffer.data[d + 2]; // 8 nibbles
    uint alpha1      = inputBuffer.data[d + 3]; // 8 nibbles

    uvec2 endpoints = uvec2(endpoints32 & 0xFFFFu, (endpoints32 >> 16) & 0xFFFFu);
    vec3 pal[4]; bool opaque;
    bc1Palette(endpoints, pal, opaque); // BC2 always opaque in color, alpha explicit

    for (uint t=0u; t<16u; ++t) {
        uint i = idx2(indices32, t);
        // Alpha 4-bit per texel: t in [0,15], first 8 from alpha0, next 8 from alpha1
        uint src = (t < 8u) ? alpha0 : alpha1;
        uint shift = (t & 7u) * 4u;
        uint a4 = (src >> shift) & 0xFu;
        float a = float(a4) * (1.0 / 15.0);

        ivec2 p = base + ivec2(int(t % 4u), int(t / 4u));
        if (p.x < dim.x && p.y < dim.y) imageStore(outputImage, p, vec4(pal[i], a));
    }
}
