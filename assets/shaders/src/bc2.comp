#version 450
#include "bc_common.glsl"
layout(local_size_x = WG_SIZE) in;

// BC2: BC1 RGB + explicit alpha block (4-bit alpha per texel)

float expand5(uint v) { return float((v << 3) | (v >> 2)) / 255.0; }
float expand6(uint v) { return float((v << 2) | (v >> 4)) / 255.0; }
vec3 color565(uint c) {
    uint r5 = (c >> 11) & 31u;
    uint g6 = (c >> 5) & 63u;
    uint b5 = c & 31u;
    return vec3(expand5(r5), expand6(g6), expand5(b5));
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    // 8 bytes alpha + 8 bytes BC1 RGB
    uint a0 = bc_words[bi * 4u + 0u];
    uint a1 = bc_words[bi * 4u + 1u];
    uint w0 = bc_words[bi * 4u + 2u];
    uint w1 = bc_words[bi * 4u + 3u];

    uint c0 = w0 & 0xFFFFu;
    uint c1 = (w0 >> 16) & 0xFFFFu;
    vec3 C0 = color565(c0);
    vec3 C1 = color565(c1);

    vec3 P[4];
    P[0] = C0; P[1] = C1;
    if (c0 > c1) { P[2] = (2.0 * C0 + C1) / 3.0; P[3] = (C0 + 2.0 * C1) / 3.0; }
    else { P[2] = (C0 + C1) / 2.0; P[3] = vec3(0.0); }

    // 16 texels: 2-bit color indices in w1; 4-bit alpha indices across a0,a1
    for (uint t = 0u; t < 16u; ++t) {
        uint cidx = (w1 >> (t * 2u)) & 3u;
        vec3 rgb = P[cidx];

        uint shift = (t * 4u);
        uint src = (shift < 32u) ? a0 : a1;
        uint s = (shift < 32u) ? shift : (shift - 32u);
        uint aval = (src >> s) & 0xFu;
        float a = float(aval) / 15.0;

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, a));
    }
}
