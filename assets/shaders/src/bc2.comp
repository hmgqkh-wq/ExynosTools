#version 450
// BC2 decoder (explicit alpha, 4 bytes alpha + 4 bytes color)
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rgba8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push { uint srcOffset; uint srcSize; uint width; uint height; } pc;

uvec4 decode_color_block(uint64_t cb) {
    uint color0 = uint(cb & 0xFFFFu);
    uint color1 = uint((cb >> 16u) & 0xFFFFu);
    uint lookup = uint((cb >> 32u) & 0xFFFFFFFFu);
    // reuse BC1 color decode (same as bc1 except alpha handled separately)
    uvec4 out[4];
    // expand 565
    out[0] = uvec4(((color0 >> 11) & 0x1Fu) * 255u / 31u, ((color0 >> 5) & 0x3Fu) * 255u / 63u, (color0 & 0x1Fu) * 255u / 31u, 255u);
    out[1] = uvec4(((color1 >> 11) & 0x1Fu) * 255u / 31u, ((color1 >> 5) & 0x3Fu) * 255u / 63u, (color1 & 0x1Fu) * 255u / 31u, 255u);
    if (color0 > color1) {
        out[2] = uvec4((2u*out[0] + out[1]) / 3u, 255u);
        out[3] = uvec4((out[0] + 2u*out[1]) / 3u, 255u);
    } else {
        out[2] = uvec4((out[0] + out[1]) / 2u, 255u);
        out[3] = uvec4(0u,0u,0u,0u);
    }
    // pack LUT and return packed values via channels when used
    return uvec4(out[0]); // placeholder: block-level return not used directly
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    uint block_x = gx / 4u;
    uint block_y = gy / 4u;
    uint blocks_per_row = (pc.width + 3u) / 4u;
    uint block_index = block_y * blocks_per_row + block_x;

    // BC2 layout: 16 bytes per block: 8 bytes alpha mask + 8 bytes color (BC1 like)
    uint byte_offset = pc.srcOffset + block_index * 16u;
    uint word_index = byte_offset / 4u;
    uint w0 = srcBuf.data[word_index];
    uint w1 = srcBuf.data[word_index + 1u];
    uint w2 = srcBuf.data[word_index + 2u];
    uint w3 = srcBuf.data[word_index + 3u];

    // alpha: first 8 bytes contain explicit 4-bit alpha per pixel -> stored little-endian into 64-bit
    uint64_t alphabits = (uint64_t(w1) << 32) | uint64_t(w0);
    uint64_t colorbits = (uint64_t(w3) << 32) | uint64_t(w2);

    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pixel_index = py * 4u + px;

    uint alpha4 = (alphabits >> (pixel_index * 4u)) & 0xFu;
    float a = float(alpha4) / 15.0;

    uint two_bits = (uint(colorbits >> (pixel_index * 2u)) & 0x3u);

    // decode colors (similar to BC1)
    uint color0 = uint(colorbits & 0xFFFFu);
    uint color1 = uint((colorbits >> 16u) & 0xFFFFu);
    uvec4 c0 = uvec4((color0 >> 11) & 0x1Fu, (color0 >> 5) & 0x3Fu, color0 & 0x1Fu, 0u);
    uvec4 c1 = uvec4((color1 >> 11) & 0x1Fu, (color1 >> 5) & 0x3Fu, color1 & 0x1Fu, 0u);
    // expand to 8bit
    uvec4 col0 = uvec4(c0.x * 255u / 31u, c0.y * 255u / 63u, c0.z * 255u / 31u, 255u);
    uvec4 col1 = uvec4(c1.x * 255u / 31u, c1.y * 255u / 63u, c1.z * 255u / 31u, 255u);
    uvec4 final;
    if (color0 > color1) {
        if (two_bits == 0u) final = col0;
        else if (two_bits == 1u) final = col1;
        else if (two_bits == 2u) final = uvec4((2u*col0 + col1)/3u, 255u);
        else final = uvec4((col0 + 2u*col1)/3u, 255u);
    } else {
        if (two_bits == 0u) final = col0;
        else if (two_bits == 1u) final = col1;
        else if (two_bits == 2u) final = uvec4((col0 + col1)/2u, 255u);
        else final = uvec4(0u,0u,0u,0u);
    }

    imageStore(dstImg, ivec2(gx, gy), vec4(final.rgb, uint(round(a * 255.0))) / 255.0);
}
