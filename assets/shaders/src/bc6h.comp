#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer InputBuffer {
    uint data[];
} inputBuffer;

layout(set = 0, binding = 1, rgba16f) uniform image2D outputImage;  // HDR format for BC6H

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy) * 4;
    uint blockIndex = (gl_GlobalInvocationID.y * (imageSize(outputImage).x / 4) + gl_GlobalInvocationID.x) * 4;

    uint mode = inputBuffer.data[blockIndex] & 0x1F;  // BC6H mode

    // Mode-specific decoding (reduce branches with if-else)
    if (mode < 8) {
        // Mode 0-7: Signed HDR
        vec4 endpoints[4];
        // Unroll endpoint extraction
        endpoints[0] = unpackBC6HEndpoint(inputBuffer.data[blockIndex], 0);
        endpoints[1] = unpackBC6HEndpoint(inputBuffer.data[blockIndex + 1], 1);
        endpoints[2] = unpackBC6HEndpoint(inputBuffer.data[blockIndex + 2], 2);
        endpoints[3] = unpackBC6HEndpoint(inputBuffer.data[blockIndex + 3], 3);

        half4 hEndpoints[4] = half4(endpoints[0]), half4(endpoints[1]), half4(endpoints[2]), half4(endpoints[3]);  // Half for math

        uint indices = inputBuffer.data[blockIndex + 4];

        for (uint y = 0u; y < 4u; y++) {
            for (uint x = 0u; x < 4u; x++) {
                uint idx = (indices >> ((y * 4 + x) * 3)) & 0x7;
                half4 color = hEndpoints[0] + (hEndpoints[1] - hEndpoints[0]) * (half(idx) / 7.0h);  // Linear interp
                imageStore(outputImage, coord + ivec2(x, y), vec4(color));
            }
        }
    } else {
        // Mode 8-14: Unsigned HDR (similar unrolled logic)
        // ... (implement similar to above, with unsigned unpacking)
    }
}
