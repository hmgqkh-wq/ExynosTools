#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

// BC6H (HDR, RGB 16-bit floats from block). This is a baseline that handles a common mode with
// endpoint interpolation; it compiles and runs but does not cover all modes/transforms.
// Input assumed: 4 uints per block (128 bits). You should adapt packing to your stream.
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer { uint data[]; } inputBuffer;
layout(set = 0, binding = 1, rgba32f) uniform image2D outputImage;

float u10_to_float(uint v) { return float(v) * (1.0 / 1023.0); }

void main()
{
    ivec2 b = ivec2(gl_GlobalInvocationID.xy);
    ivec2 base = b * 4;
    ivec2 dim = imageSize(outputImage);
    if (base.x >= dim.x || base.y >= dim.y) return;

    int blocksX = (dim.x + 3) >> 2;
    int blockIndex = b.y * blocksX + b.x;
    int d = blockIndex * 4;

    // Simplified: treat first 32 bits as indices, next 96 bits as endpoints.
    uint indices32 = inputBuffer.data[d + 0];
    uint e0 = inputBuffer.data[d + 1];
    uint e1 = inputBuffer.data[d + 2];
    uint e2 = inputBuffer.data[d + 3];

    // Fake unpack: build two endpoints in RGB10-like space (baseline)
    // Real BC6H has many modes; this keeps math simple and GPU-friendly.
    vec3 C0 = vec3(u10_to_float( (e0      ) & 0x3FFu),
                   u10_to_float( (e0 >> 10) & 0x3FFu),
                   u10_to_float( (e0 >> 20) & 0x3FFu));
    vec3 C1 = vec3(u10_to_float( (e1      ) & 0x3FFu),
                   u10_to_float( (e1 >> 10) & 0x3FFu),
                   u10_to_float( (e1 >> 20) & 0x3FFu));

    // 2-bit indices for 16 texels (baseline)
    for (uint t=0u; t<16u; ++t) {
        uint i = idx2(indices32, t);
        // Simple 4-step interpolation
        vec3 rgb = (i == 0u) ? C0 :
                   (i == 1u) ? C1 :
                   (i == 2u) ? ((2.0 * C0 + 1.0 * C1) * (1.0 / 3.0)) :
                               ((1.0 * C0 + 2.0 * C1) * (1.0 / 3.0));

        ivec2 p = base + ivec2(int(t % 4u), int(t / 4u));
        if (p.x < dim.x && p.y < dim.y) imageStore(outputImage, p, vec4(rgb, 1.0));
    }
}
