#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

// BC6H (HDR) decode (linear RGB, half float-like packed)
// This is a simplified path that handles common modes (signed/unsigned, most frequent subset).
// For full spec coverage, expand mode parsing. Outputs clamped [0..1] after tone-map.

uint get_bit(uint v, uint b) { return (v >> b) & 1u; }
uint bits(uint v, uint s, uint n) { return (v >> s) & ((1u << n) - 1u); }

float expand_10(uint v) { return float(v) / 1023.0; }
float expand_11(uint v) { return float(v) / 2047.0; }

void main() {
    uint blockIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * PC.groupsX;
    uvec2 origin = block_origin(blockIndex);

    // BC6H is 16 bytes per block (4 dwords)
    uint b0 = bc_words[blockIndex * 4u + 0u];
    uint b1 = bc_words[blockIndex * 4u + 1u];
    uint b2 = bc_words[blockIndex * 4u + 2u];
    uint b3 = bc_words[blockIndex * 4u + 3u];

    // Mode bits are in low bits of b0; choose unsigned mode common case
    // This is a minimal decode path: treat endpoints as 10/11-bit, interpolate via indices.
    // Real BC6H has multiple modes with partition sets and P-bits.
    // Here: single partition, 2 endpoints, 4x4 indices 4 bits each.

    // Endpoint extraction (approximate):
    uint R0 = bits(b0, 5, 10);
    uint G0 = bits(b0, 15, 10);
    uint B0 = bits(b0, 25, 7) | (bits(b1, 0, 3) << 7);
    uint R1 = bits(b1, 3, 10);
    uint G1 = bits(b1, 13, 10);
    uint B1 = bits(b1, 23, 9) | (bits(b2, 0, 1) << 9);

    vec3 c0 = vec3(expand_10(R0), expand_10(G0), expand_11(B0));
    vec3 c1 = vec3(expand_10(R1), expand_10(G1), expand_11(B1));

    // Indices: 16 texels, 4 bits each = 64 bits starting in b2|b3
    // Pack them linearly for simplicity
    uint64_t idx64 = uint64_t(b2) | (uint64_t(b3) << 32);

    for (uint py = 0u; py < 4u; ++py) {
        for (uint px = 0u; px < 4u; ++px) {
            uint t = py * 4u + px;
            uint shift = t * 4u;
            uint idx = uint((idx64 >> shift) & 15u); // 0..15
            float w = float(idx) / 15.0;
            vec3 rgb = mix(c0, c1, w);

            // Simple tone-map to [0..1] to fit RGBA8
            rgb = rgb / (rgb + vec3(1.0));
            store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, 1.0));
        }
    }
}
