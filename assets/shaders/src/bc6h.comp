#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

struct ModeMeta {
    uint partitions;
    bool isSigned;
    bool hasPBits;
    uint epBitsR; uint epBitsG; uint epBitsB;
    uint idxBits;
};

ModeMeta meta_from_header(uint b0) {
    ModeMeta m;
    m.partitions = ((b0 >> 6) & 1u) != 0u ? 2u : 1u;
    m.isSigned   = ((b0 >> 5) & 1u) != 0u;
    m.hasPBits   = ((b0 >> 7) & 1u) != 0u;
    m.epBitsR = 10u; m.epBitsG = 10u; m.epBitsB = 11u;
    m.idxBits = 4u;
    if ((b0 & 0x04u) != 0u) { m.epBitsB = 10u; }
    return m;
}

float expand_channel(uint v, uint bits, bool isSigned) {
    return isSigned ? snormN(v, bits) : unormN(v, bits);
}

uvec3 read_endpoint_triplet(uint b0, uint b1, uint b2, uint b3, ModeMeta m, uint whichEP) {
    if (whichEP == 0u) {
        uint R0 = (b0 >> 5) & ((1u << m.epBitsR) - 1u);
        uint G0 = (b0 >> 15) & ((1u << m.epBitsG) - 1u);
        uint B0 = ((b0 >> 25) & ((1u << min(7u, m.epBitsB)) - 1u)) | ((b1 & 0x7u) << 7);
        return uvec3(R0, G0, B0);
    } else {
        uint R1 = (b1 >> 3) & ((1u << m.epBitsR) - 1u);
        uint G1 = (b1 >> 13) & ((1u << m.epBitsG) - 1u);
        uint B1 = ((b1 >> 23) & ((1u << min(9u, m.epBitsB)) - 1u)) | ((b2 & 0x1u) << 9);
        return uvec3(R1, G1, B1);
    }
}

vec3 apply_pbits(vec3 c, ModeMeta m) {
    if (!m.hasPBits) return c;
    return clamp(c + vec3(1.0 / 1023.0, 1.0 / 1023.0, 1.0 / 2047.0), 0.0, 1.0);
}

vec3 tone_map(vec3 hdr) {
    return hdr / (hdr + vec3(1.0));
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    uint b0 = bc_words[bi * 4u + 0u];
    uint b1 = bc_words[bi * 4u + 1u];
    uint b2 = bc_words[bi * 4u + 2u];
    uint b3 = bc_words[bi * 4u + 3u];

    ModeMeta m = meta_from_header(b0);

    uvec3 e0u = read_endpoint_triplet(b0, b1, b2, b3, m, 0u);
    uvec3 e1u = read_endpoint_triplet(b0, b1, b2, b3, m, 1u);

    vec3 E0 = vec3(expand_channel(e0u.x, m.epBitsR, m.isSigned),
                   expand_channel(e0u.y, m.epBitsG, m.isSigned),
                   expand_channel(e0u.z, m.epBitsB, m.isSigned));
    vec3 E1 = vec3(expand_channel(e1u.x, m.epBitsR, m.isSigned),
                   expand_channel(e1u.y, m.epBitsG, m.isSigned),
                   expand_channel(e1u.z, m.epBitsB, m.isSigned));

    E0 = apply_pbits(E0, m);
    E1 = apply_pbits(E1, m);

    uint64_t idx64 = uint64_t(b2) | (uint64_t(b3) << 32);
    uint maxIdx = (1u << m.idxBits) - 1u;

    for (uint t = 0u; t < 16u; ++t) {
        uint idx = uint((idx64 >> (t * m.idxBits)) & maxIdx);
        float w = float(idx) / float(maxIdx);
        vec3 rgb = mix(E0, E1, w);
        rgb = tone_map(rgb);

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, 1.0));
    }
}
