#version 450
#extension GL_GOOGLE_include_directive : enable
#include "bc_common.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;  // Optimized for RDNA3

layout(set = 0, binding = 0) buffer InputBuffer {
    uint data[];
} inputBuffer;

layout(set = 0, binding = 1, rgba8) uniform image2D outputImage;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy) * 4;
    uint blockIndex = (gl_GlobalInvocationID.y * (imageSize(outputImage).x / 4) + gl_GlobalInvocationID.x) * 4;  // 16 bytes per block

    // Color part (BC1)
    uint lowColor = inputBuffer.data[blockIndex + 2];
    uint highColor = inputBuffer.data[blockIndex + 3];

    vec4 color0 = unpackColor(lowColor);
    vec4 color1 = unpackColor(highColor);

    half4 hcolor0 = half4(color0.rgb, 1.0h);  // Half for RGB
    half4 hcolor1 = half4(color1.rgb, 1.0h);

    half4 colors[4];
    colors[0] = hcolor0;
    colors[1] = hcolor1;
    colors[2] = hcolor0 * (2.0h / 3.0h) + hcolor1 * (1.0h / 3.0h);
    colors[3] = hcolor0 * (1.0h / 3.0h) + hcolor1 * (2.0h / 3.0h);

    uint colorIndices = inputBuffer.data[blockIndex + 4];

    // Alpha part
    uint alphaLow = inputBuffer.data[blockIndex];
    uint alphaHigh = inputBuffer.data[blockIndex + 1];

    float a0 = unpackAlpha(alphaLow);
    float a1 = unpackAlpha(alphaHigh);

    float alphas[8];
    alphas[0] = a0;
    alphas[1] = a1;
    // Unroll alpha interpolation
    alphas[2] = (6.0 * a0 + 1.0 * a1) / 7.0;
    alphas[3] = (5.0 * a0 + 2.0 * a1) / 7.0;
    alphas[4] = (4.0 * a0 + 3.0 * a1) / 7.0;
    alphas[5] = (3.0 * a0 + 4.0 * a1) / 7.0;
    alphas[6] = (2.0 * a0 + 5.0 * a1) / 7.0;
    alphas[7] = (1.0 * a0 + 6.0 * a1) / 7.0;

    uint alphaIndices = inputBuffer.data[blockIndex + 5];

    // Unroll pixel write
    for (uint y = 0u; y < 4u; y++) {
        for (uint x = 0u; x < 4u; x++) {
            uint cIdx = (colorIndices >> ((y * 4 + x) * 2)) & 0x3;
            uint aIdx = (alphaIndices >> ((y * 4 + x) * 3)) & 0x7;
            vec4 color = vec4(colors[cIdx].rgb, alphas[aIdx]);
            imageStore(outputImage, coord + ivec2(x, y), color);
        }
    }
}
