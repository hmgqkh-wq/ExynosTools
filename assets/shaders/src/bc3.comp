#version 450
// BC3 decoder (explicit alpha via BC4-like per-block; color uses BC1 pattern)
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rgba8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push { uint srcOffset; uint srcSize; uint width; uint height; } pc;

float decode_alpha(uint64_t alphabits, uint px_idx) {
    // alphabits encodes alpha endpoints and 3-bit indices per pixel (64 bits)
    uint idx = (alphabits >> (px_idx * 3u)) & 0x7u;
    return float(idx) / 7.0; // simplified linear mapping; production code uses endpoints interpolation
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    uint block_x = gx / 4u;
    uint block_y = gy / 4u;
    uint blocks_per_row = (pc.width + 3u) / 4u;
    uint block_index = block_y * blocks_per_row + block_x;

    uint byte_offset = pc.srcOffset + block_index * 16u;
    uint word_index = byte_offset / 4u;

    uint w0 = srcBuf.data[word_index];
    uint w1 = srcBuf.data[word_index + 1u];
    uint w2 = srcBuf.data[word_index + 2u];
    uint w3 = srcBuf.data[word_index + 3u];

    uint64_t alpha64 = (uint64_t(w1) << 32) | uint64_t(w0);
    uint64_t color64 = (uint64_t(w3) << 32) | uint64_t(w2);

    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pixel_index = py * 4u + px;

    float a = decode_alpha(alpha64, pixel_index);

    // color decode reuse of bc1 logic (simplified)
    uint color0 = uint(color64 & 0xFFFFu);
    uint color1 = uint((color64 >> 16u) & 0xFFFFu);
    uint two_bits = uint((color64 >> 32u) >> (pixel_index * 2u)) & 0x3u;

    uvec4 col0 = uvec4(((color0 >> 11) & 0x1Fu) * 255u / 31u, ((color0 >> 5) & 0x3Fu) * 255u / 63u, (color0 & 0x1Fu) * 255u / 31u, 255u);
    uvec4 col1 = uvec4(((color1 >> 11) & 0x1Fu) * 255u / 31u, ((color1 >> 5) & 0x3Fu) * 255u / 63u, (color1 & 0x1Fu) * 255u / 31u, 255u);
    uvec4 final;
    if (color0 > color1) {
        if (two_bits == 0u) final = col0;
        else if (two_bits == 1u) final = col1;
        else if (two_bits == 2u) final = uvec4((2u*col0 + col1)/3u, 255u);
        else final = uvec4((col0 + 2u*col1)/3u, 255u);
    } else {
        if (two_bits == 0u) final = col0;
        else if (two_bits == 1u) final = col1;
        else if (two_bits == 2u) final = uvec4((col0 + col1)/2u, 255u);
        else final = uvec4(0u,0u,0u,0u);
    }

    imageStore(dstImg, ivec2(gx, gy), vec4(final.rgb, round(a * 255.0)) / 255.0);
}
