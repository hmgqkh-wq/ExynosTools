#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

// BC3 (DXT5) decode: 16 bytes per block
// First 8 bytes: alpha block (a0,a1, 48 bits indices)
// Next 8 bytes: same as BC1 color

float decode_alpha(uint64_t alphaBits, uint a0, uint a1, uint idx) {
    float fa0 = float(a0) / 255.0;
    float fa1 = float(a1) / 255.0;
    if (a0 > a1) {
        // 8-alpha block
        if (idx == 0u) return fa0;
        if (idx == 1u) return fa1;
        return ((8.0 - float(idx)) * fa0 + (float(idx) - 1.0) * fa1) / 7.0;
    } else {
        // 6-alpha block + 0,1
        if (idx == 0u) return fa0;
        if (idx == 1u) return fa1;
        if (idx == 6u) return 0.0;
        if (idx == 7u) return 1.0;
        return ((6.0 - float(idx)) * fa0 + (float(idx) - 1.0) * fa1) / 5.0;
    }
}

vec3 rgb565_to_rgb(uint c) {
    float r = u5_to_float(u5(c, 11));
    float g = u6_to_float(u6(c, 5));
    float b = u5_to_float(u5(c, 0));
    return vec3(r, g, b);
}

void main() {
    uint blockIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * PC.groupsX;
    uvec2 origin = block_origin(blockIndex);

    // Alpha block: 2 dwords = 64 bits
    uint a0a1 = bc_words[blockIndex * 4u + 0u];
    uint aIdxLo = bc_words[blockIndex * 4u + 1u];
    uint aIdxHi = bc_words[blockIndex * 4u + 2u]; // upper 16 bits used

    uint a0 = a0a1 & 0xffu;
    uint a1 = (a0a1 >> 8) & 0xffu;

    // Gather 48-bit alpha indices (3 bits per texel)
    // Pack into 64-bit for convenience
    uint64_t alphaBits = uint64_t(aIdxLo) | (uint64_t(aIdxHi & 0xffffu) << 32);

    // Color block: BC1 layout in last 8 bytes
    uint wColor0 = bc_words[blockIndex * 4u + 2u]; // remaining upper bits overlapped; safer to use next dword
    uint wColor1 = bc_words[blockIndex * 4u + 3u];

    uint c0 = wColor0 & 0xffffu;
    uint c1 = (wColor0 >> 16) & 0xffffu;
    vec3 c0_rgb = rgb565_to_rgb(c0);
    vec3 c1_rgb = rgb565_to_rgb(c1);
    vec3 palette[4];
    palette[0] = c0_rgb;
    palette[1] = c1_rgb;
    palette[2] = (2.0 * c0_rgb + c1_rgb) / 3.0;
    palette[3] = (c0_rgb + 2.0 * c1_rgb) / 3.0;

    uint colorIdxBits = wColor1;

    for (uint py = 0u; py < 4u; ++py) {
        for (uint px = 0u; px < 4u; ++px) {
            uint texel = py * 4u + px;

            // Alpha index: 3 bits per texel
            uint64_t abitShift = uint64_t(texel) * 3u;
            uint aidx = uint((alphaBits >> abitShift) & 7u);
            float A = decode_alpha(alphaBits, a0, a1, aidx);

            // Color index: 2 bits per texel
            uint cidx = (colorIdxBits >> (texel * 2u)) & 3u;
            vec3 rgb = palette[cidx];

            store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, A));
        }
    }
}
