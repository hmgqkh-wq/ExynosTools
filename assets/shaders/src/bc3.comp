#version 450
#include "bc_common.glsl"
layout(local_size_x = 64) in;

// BC3: BC1 color + BC4 alpha block (endpoints + 3-bit indices)

float expand5(uint v) { return float((v << 3) | (v >> 2)) / 255.0; }
float expand6(uint v) { return float((v << 2) | (v >> 4)) / 255.0; }
vec3 color565(uint c) {
    uint r5 = (c >> 11) & 31u;
    uint g6 = (c >> 5) & 63u;
    uint b5 = c & 31u;
    return vec3(expand5(r5), expand6(g6), expand5(b5));
}

float alpha_interp(uint a0, uint a1, uint idx) {
    float A0 = float(a0) / 255.0;
    float A1 = float(a1) / 255.0;
    if (a0 > a1) {
        if (idx == 0u) return A0;
        if (idx == 1u) return A1;
        return ((8.0 - float(idx)) * A0 + (float(idx) - 1.0) * A1) / 7.0;
    } else {
        if (idx == 0u) return A0;
        if (idx == 1u) return A1;
        if (idx == 6u) return 0.0;
        if (idx == 7u) return 1.0;
        return ((6.0 - float(idx)) * A0 + (float(idx) - 1.0) * A1) / 5.0;
    }
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    // Alpha block (BC4 style): a0,a1 (8-bit), then 48-bit indices
    uint a0a1 = bc_words[bi * 4u + 0u];
    uint ai_lo = bc_words[bi * 4u + 1u];
    uint ai_hi16 = bc_words[bi * 4u + 2u] & 0xFFFFu;

    // Color block (BC1): endpoints/indices
    uint w0 = bc_words[bi * 4u + 3u - 1u]; // reuse a0a1 upper for endpoints if packed adjacently
    uint w1 = bc_words[bi * 4u + 3u];

    uint c0 = w0 & 0xFFFFu;
    uint c1 = (w0 >> 16) & 0xFFFFu;

    vec3 C0 = color565(c0);
    vec3 C1 = color565(c1);

    vec3 P[4];
    P[0] = C0; P[1] = C1;
    if (c0 > c1) { P[2] = (2.0 * C0 + C1) / 3.0; P[3] = (C0 + 2.0 * C1) / 3.0; }
    else { P[2] = (C0 + C1) / 2.0; P[3] = vec3(0.0); }

    uint a0 = a0a1 & 0xFFu;
    uint a1 = (a0a1 >> 8) & 0xFFu;

    for (uint t = 0u; t < 16u; ++t) {
        uint cidx = read2_32(w1, t * 2u);
        vec3 rgb = P[cidx];

        uint aidx = read3_48(ai_lo, ai_hi16, t * 3u);
        float a = alpha_interp(a0, a1, aidx);

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, a));
    }
}
