#version 450
#include "bc_common.glsl"
layout(local_size_x = 64) in;

// BC7: optimized common-mode decode (RGB/RGBA), partitions and p-bits bias

float expand_unorm(uint v, uint bits) { return unormN(v, bits); }

struct ModeMeta {
    uint indexBits;
    uint chanBits;
    bool pBits;
    uint partitions;
    bool hasAlpha;
};

ModeMeta parse_mode(uint b0) {
    uint mode = 0u;
    for (uint i = 0u; i < 8u; ++i) { if (((b0 >> i) & 1u) != 0u) { mode = i; break; } }

    ModeMeta m;
    if (mode == 0u) { m.indexBits = 3u; m.chanBits = 7u; m.pBits = true;  m.partitions = 1u; m.hasAlpha = false; }
    else if (mode == 1u) { m.indexBits = 3u; m.chanBits = 6u; m.pBits = true;  m.partitions = 2u; m.hasAlpha = false; }
    else if (mode == 6u) { m.indexBits = 4u; m.chanBits = 8u; m.pBits = false; m.partitions = 1u; m.hasAlpha = true; }
    else { m.indexBits = 3u; m.chanBits = 7u; m.pBits = true;  m.partitions = 1u; m.hasAlpha = false; }
    return m;
}

vec4 read_ep(uint wA, uint wB, ModeMeta m, uint whichEP) {
    uint mask = (1u << m.chanBits) - 1u;
    if (whichEP == 0u) {
        uint R = (wA >> 0) & mask;
        uint G = (wA >> m.chanBits) & mask;
        uint B = (wB >> 0) & mask;
        uint A = m.hasAlpha ? ((wB >> m.chanBits) & mask) : mask;
        return vec4(expand_unorm(R, m.chanBits),
                    expand_unorm(G, m.chanBits),
                    expand_unorm(B, m.chanBits),
                    expand_unorm(A, m.chanBits));
    } else {
        uint R = (wB >> (m.chanBits * 2u)) & mask;
        uint G = (wB >> (m.chanBits * 3u)) & mask;
        uint B = (wA >> (m.chanBits * 2u)) & mask;
        uint A = m.hasAlpha ? ((wA >> (m.chanBits * 3u)) & mask) : mask;
        return vec4(expand_unorm(R, m.chanBits),
                    expand_unorm(G, m.chanBits),
                    expand_unorm(B, m.chanBits),
                    expand_unorm(A, m.chanBits));
    }
}

vec3 apply_pbits_rgb(vec3 c, ModeMeta m) {
    if (!m.pBits) return c;
    float q = (m.chanBits == 7u) ? 1.0 / 127.0 : 1.0 / 63.0;
    return clamp(c + vec3(q), 0.0, 1.0);
}

uint partitionForTexel(uint t) {
    uint x = t & 3u;
    return (x < 2u) ? 0u : 1u;
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    uint w0 = bc_words[bi * 4u + 0u];
    uint w1 = bc_words[bi * 4u + 1u];
    uint w2 = bc_words[bi * 4u + 2u];
    uint w3 = bc_words[bi * 4u + 3u];

    ModeMeta m = parse_mode(w0);

    vec4 E0 = read_ep(w0, w1, m, 0u);
    vec4 E1 = read_ep(w2, w3, m, 1u);

    vec3 C0 = apply_pbits_rgb(E0.rgb, m);
    vec3 C1 = apply_pbits_rgb(E1.rgb, m);
    float A0 = E0.a;
    float A1 = E1.a;

    uint idx_lo = w2;
    uint idx_hi = w3;
    uint maxIdx = (1u << m.indexBits) - 1u;

    for (uint t = 0u; t < 16u; ++t) {
        uint pos = t * m.indexBits;
        uint idx = read4_64(idx_lo, idx_hi, pos) & maxIdx;
        float w = float(idx) / float(maxIdx);

        uint part = (m.partitions == 1u) ? 0u : partitionForTexel(t);

        vec3 rgb = (part == 0u) ? mix(C0, C1, w) : mix(C1, C0, w);
        float a  = m.hasAlpha ? mix(A0, A1, w) : 1.0;

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, a));
    }
}
