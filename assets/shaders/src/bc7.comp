#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

// BC7 has multiple modes; we simplify by handling the most common RGB modes.
// This shader decodes endpoints and interpolates colors per pixel.

struct ModeMeta {
    uint indexBits;
    uint chanBits;
    bool pBits;
    uint partitions;
    bool hasAlpha;
};

// Simplified mode metadata (real BC7 has 8 modes; here we cover RGB + alpha)
ModeMeta meta_from_header(uint b0) {
    ModeMeta m;
    uint mode = 0u;
    // Mode detection: lowest set bit in first byte
    for (uint i = 0u; i < 8u; ++i) {
        if (((b0 >> i) & 1u) != 0u) { mode = i; break; }
    }

    // Simplified mapping
    if (mode == 0u) { // RGB, 3 bits index
        m.indexBits = 3u; m.chanBits = 7u; m.pBits = true; m.partitions = 1u; m.hasAlpha = false;
    } else if (mode == 1u) { // RGB, 2 partitions
        m.indexBits = 3u; m.chanBits = 6u; m.pBits = true; m.partitions = 2u; m.hasAlpha = false;
    } else if (mode == 6u) { // RGBA
        m.indexBits = 4u; m.chanBits = 8u; m.pBits = false; m.partitions = 1u; m.hasAlpha = true;
    } else { // fallback
        m.indexBits = 3u; m.chanBits = 7u; m.pBits = true; m.partitions = 1u; m.hasAlpha = false;
    }
    return m;
}

float expand_channel(uint v, uint bits) {
    return unormN(v, bits);
}

vec4 read_endpoint(uint w0, uint w1, ModeMeta m, uint whichEP) {
    // Simplified: assume endpoints packed in w0/w1
    if (whichEP == 0u) {
        uint R = (w0 >> 0) & ((1u << m.chanBits) - 1u);
        uint G = (w0 >> m.chanBits) & ((1u << m.chanBits) - 1u);
        uint B = (w1 >> 0) & ((1u << m.chanBits) - 1u);
        uint A = m.hasAlpha ? ((w1 >> m.chanBits) & ((1u << m.chanBits) - 1u)) : (1u << m.chanBits) - 1u;
        return vec4(expand_channel(R, m.chanBits),
                    expand_channel(G, m.chanBits),
                    expand_channel(B, m.chanBits),
                    expand_channel(A, m.chanBits));
    } else {
        uint R = (w1 >> (m.chanBits * 2u)) & ((1u << m.chanBits) - 1u);
        uint G = (w1 >> (m.chanBits * 3u)) & ((1u << m.chanBits) - 1u);
        uint B = (w0 >> (m.chanBits * 2u)) & ((1u << m.chanBits) - 1u);
        uint A = m.hasAlpha ? ((w0 >> (m.chanBits * 3u)) & ((1u << m.chanBits) - 1u)) : (1u << m.chanBits) - 1u;
        return vec4(expand_channel(R, m.chanBits),
                    expand_channel(G, m.chanBits),
                    expand_channel(B, m.chanBits),
                    expand_channel(A, m.chanBits));
    }
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    uint w0 = bc_words[bi * 4u + 0u];
    uint w1 = bc_words[bi * 4u + 1u];
    uint w2 = bc_words[bi * 4u + 2u];
    uint w3 = bc_words[bi * 4u + 3u];

    ModeMeta m = meta_from_header(w0);

    vec4 E0 = read_endpoint(w0, w1, m, 0u);
    vec4 E1 = read_endpoint(w2, w3, m, 1u);

    uint64_t idxBits = uint64_t(w2) | (uint64_t(w3) << 32);
    uint maxIdx = (1u << m.indexBits) - 1u;

    for (uint t = 0u; t < 16u; ++t) {
        uint idx = uint((idxBits >> (t * m.indexBits)) & maxIdx);
        float w = float(idx) / float(maxIdx);
        vec4 rgba = mix(E0, E1, w);

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), rgba);
    }
}
