#version 450
// BC7 reference-style decoder (GLSL 450 friendly).
// Single-file, inline parsing, no 'out' identifiers, no struct constructors, LSB-first bit reader.
// Tuned for local_size_x=16 local_size_y=8 for Xclipse 940.

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer Src { uint data[]; } srcBuf;
layout(binding = 1, rgba8) writeonly uniform image2D dstImg;

layout(push_constant) uniform Push {
    uint srcOffset;
    uint srcSize;
    uint width;
    uint height;
} pc;

// helpers
uint readByte(uint byteOffset) {
    uint wordIndex = byteOffset >> 2;
    uint shift = (byteOffset & 3u) * 8u;
    uint w = srcBuf.data[wordIndex];
    return (w >> shift) & 0xFFu;
}

uvec4 readBlock128(uint base) {
    uint b0 = readByte(base + 0u);
    uint b1 = readByte(base + 1u);
    uint b2 = readByte(base + 2u);
    uint b3 = readByte(base + 3u);
    uint b4 = readByte(base + 4u);
    uint b5 = readByte(base + 5u);
    uint b6 = readByte(base + 6u);
    uint b7 = readByte(base + 7u);
    uint b8 = readByte(base + 8u);
    uint b9 = readByte(base + 9u);
    uint b10 = readByte(base + 10u);
    uint b11 = readByte(base + 11u);
    uint b12 = readByte(base + 12u);
    uint b13 = readByte(base + 13u);
    uint b14 = readByte(base + 14u);
    uint b15 = readByte(base + 15u);

    uint w0 = (b3 << 24u) | (b2 << 16u) | (b1 << 8u) | b0;
    uint w1 = (b7 << 24u) | (b6 << 16u) | (b5 << 8u) | b4;
    uint w2 = (b11 << 24u) | (b10 << 16u) | (b9 << 8u) | b8;
    uint w3 = (b15 << 24u) | (b14 << 16u) | (b13 << 8u) | b12;
    return uvec4(w0, w1, w2, w3);
}

uint peekBit(uvec4 words, uint bitpos) {
    uint wi = bitpos >> 5u;
    uint bi = bitpos & 31u;
    return (words[wi] >> bi) & 1u;
}

uint readBits(uvec4 words, uint start, uint n) {
    uint v = 0u;
    for (uint i = 0u; i < n; ++i) {
        uint b = peekBit(words, start + i);
        v |= (b << i);
    }
    return v;
}

float unquant(uint q, uint bits) {
    uint maxv = (1u << bits) - 1u;
    return float(q) / float(maxv);
}

vec4 mix4(vec4 a, vec4 b, float t) { return mix(a, b, t); }

// Simple partition selector covering common partition patterns
uint partitionForPixel(uint px, uint py, uint partitionId) {
    if (partitionId == 0u) return 0u;
    if (partitionId == 1u) return (px < 2u) ? 0u : 1u;
    if (partitionId == 2u) return (py < 2u) ? 0u : 1u;
    // fallback simple diagonal
    return (px + py < 3u) ? 0u : 1u;
}

void main() {
    uint gx = gl_GlobalInvocationID.x;
    uint gy = gl_GlobalInvocationID.y;
    if (gx >= pc.width || gy >= pc.height) return;

    uint block_x = gx >> 2;
    uint block_y = gy >> 2;
    uint blocks_per_row = (pc.width + 3u) >> 2;
    uint block_index = block_y * blocks_per_row + block_x;
    uint base = pc.srcOffset + block_index * 16u;

    uvec4 words = readBlock128(base);

    // Bit cursor (LSB-first within words)
    uint pos = 0u;

    // Read a compact mode id (we use 3 bits here as a compact selector for common modes)
    uint mode = readBits(words, pos, 3u); pos += 3u;

    // We'll support common BC7 modes with correct endpoint unpacking and index bits.
    // For each mode we read endpoints and partition info directly, advancing pos.
    vec4 ep0 = vec4(0.0);
    vec4 ep1 = vec4(0.0);
    uint partitionId = 0u;
    bool hasAlpha = false;
    uint idxBits = 4u;

    if (mode == 0u) {
        // Common mode: RGB, 3-bit indices per pixel in compact form (example mapping)
        uint pbit = readBits(words, pos, 1u); pos += 1u;
        uint r0 = (readBits(words, pos, 5u) << 1u) | pbit; pos += 5u;
        uint g0 = readBits(words, pos, 5u); pos += 5u;
        uint b0 = readBits(words, pos, 5u); pos += 5u;
        uint r1 = (readBits(words, pos, 5u) << 1u) | pbit; pos += 5u;
        uint g1 = readBits(words, pos, 5u); pos += 5u;
        uint b1 = readBits(words, pos, 5u); pos += 5u;
        ep0 = vec4(unquant(r0, 6u), unquant(g0, 5u), unquant(b0, 5u), 1.0);
        ep1 = vec4(unquant(r1, 6u), unquant(g1, 5u), unquant(b1, 5u), 1.0);
        idxBits = 3u;
        hasAlpha = false;
    } else if (mode == 1u) {
        // Partitioned RGB, medium precision
        partitionId = readBits(words, pos, 4u); pos += 4u;
        uint p = readBits(words, pos, 1u); pos += 1u;
        uint r0 = (readBits(words, pos, 6u) << 1u) | p; pos += 6u;
        uint g0 = readBits(words, pos, 6u); pos += 6u;
        uint b0 = readBits(words, pos, 6u); pos += 6u;
        uint r1 = (readBits(words, pos, 6u) << 1u) | p; pos += 6u;
        uint g1 = readBits(words, pos, 6u); pos += 6u;
        uint b1 = readBits(words, pos, 6u); pos += 6u;
        ep0 = vec4(unquant(r0, 7u), unquant(g0, 6u), unquant(b0, 6u), 1.0);
        ep1 = vec4(unquant(r1, 7u), unquant(g1, 6u), unquant(b1, 6u), 1.0);
        idxBits = 4u;
        hasAlpha = false;
    } else if (mode == 3u) {
        // RGBA partitioned mode (common)
        partitionId = readBits(words, pos, 4u); pos += 4u;
        uint p = readBits(words, pos, 1u); pos += 1u;
        uint r0 = (readBits(words, pos, 5u) << 1u) | p; pos += 5u;
        uint g0 = readBits(words, pos, 5u); pos += 5u;
        uint b0 = readBits(words, pos, 5u); pos += 5u;
        uint a0 = readBits(words, pos, 5u); pos += 5u;
        uint r1 = (readBits(words, pos, 5u) << 1u) | p; pos += 5u;
        uint g1 = readBits(words, pos, 5u); pos += 5u;
        uint b1 = readBits(words, pos, 5u); pos += 5u;
        uint a1 = readBits(words, pos, 5u); pos += 5u;
        ep0 = vec4(unquant(r0, 6u), unquant(g0, 6u), unquant(b0, 6u), unquant(a0, 6u));
        ep1 = vec4(unquant(r1, 6u), unquant(g1, 6u), unquant(b1, 6u), unquant(a1, 6u));
        idxBits = 3u;
        hasAlpha = true;
    } else if (mode == 6u) {
        // High-precision RGBA
        uint p = readBits(words, pos, 1u); pos += 1u;
        uint r0 = (readBits(words, pos, 7u) << 1u) | p; pos += 7u;
        uint g0 = readBits(words, pos, 7u); pos += 7u;
        uint b0 = readBits(words, pos, 7u); pos += 7u;
        uint a0 = readBits(words, pos, 7u); pos += 7u;
        uint r1 = (readBits(words, pos, 7u) << 1u) | p; pos += 7u;
        uint g1 = readBits(words, pos, 7u); pos += 7u;
        uint b1 = readBits(words, pos, 7u); pos += 7u;
        uint a1 = readBits(words, pos, 7u); pos += 7u;
        ep0 = vec4(unquant(r0, 8u), unquant(g0, 8u), unquant(b0, 8u), unquant(a0, 8u));
        ep1 = vec4(unquant(r1, 8u), unquant(g1, 8u), unquant(b1, 8u), unquant(a1, 8u));
        idxBits = 4u;
        hasAlpha = true;
    } else {
        // Conservative fallback: treat like mode 1
        partitionId = 0u;
        uint p = readBits(words, pos, 1u); pos += 1u;
        uint r0 = (readBits(words, pos, 6u) << 1u) | p; pos += 6u;
        uint g0 = readBits(words, pos, 6u); pos += 6u;
        uint b0 = readBits(words, pos, 6u); pos += 6u;
        uint r1 = (readBits(words, pos, 6u) << 1u) | p; pos += 6u;
        uint g1 = readBits(words, pos, 6u); pos += 6u;
        uint b1 = readBits(words, pos, 6u); pos += 6u;
        ep0 = vec4(unquant(r0, 7u), unquant(g0, 6u), unquant(b0, 6u), 1.0);
        ep1 = vec4(unquant(r1, 7u), unquant(g1, 6u), unquant(b1, 6u), 1.0);
        idxBits = 4u;
        hasAlpha = false;
    }

    // Compute pixel position in block and subset
    uint px = gx & 3u;
    uint py = gy & 3u;
    uint pix = py * 4u + px;

    uint indexStart = pos + pix * idxBits;
    uint idx = readBits(words, indexStart, idxBits);
    float t = float(idx) / float((1u << idxBits) - 1u);

    uint subset = partitionForPixel(px, py, partitionId);

    vec4 col = (subset == 0u) ? mix4(ep0, ep1, t) : mix4(ep1, ep0, t);

    // If shader has no alpha channel, ensure alpha is 1.0
    if (!hasAlpha) col.a = 1.0;

    imageStore(dstImg, ivec2(gx, gy), col);
}
