#version 450
#include "bc_common.glsl"
layout(local_size_x_id = 0) in;

// BC7 supports 8 modes with different endpoint quantizations, p-bits, partitions, alpha.
// FPS-first strategy:
// - Parse mode compactly (leading ones heuristic)
// - Reconstruct endpoints once per block
// - Per-texel loop uses fixed index width per mode, straight-line arithmetic
// - Partitions handled by computing both endpoint pairs and selecting via mask (no branches in inner loop)

struct ModeMeta {
    uint indexBits;   // per-texel index bits
    uint chanBits;    // base bits per color channel
    bool pBits;
    uint partitions;  // 1 or 2
    bool hasAlpha;    // modes with alpha
};

ModeMeta meta_from_header(uint b0) {
    // Leading 1s then a 0 define mode; compact approximation that maps well in practice.
    uint mode = 0u;
    if ((b0 & 1u) == 0u) mode = 0u;
    else if ((b0 & 3u) == 1u) mode = 1u;
    else if ((b0 & 7u) == 3u) mode = 2u;
    else if ((b0 & 15u) == 7u) mode = 3u;
    else if ((b0 & 31u) == 15u) mode = 4u;
    else if ((b0 & 63u) == 31u) mode = 5u;
    else if ((b0 & 127u) == 63u) mode = 6u;
    else mode = 7u;

    ModeMeta m;
    m.indexBits = 4u; m.chanBits = 7u; m.pBits = true; m.partitions = 1u; m.hasAlpha = false;
    if (mode == 0u) { m.indexBits = 3u; m.chanBits = 5u; m.pBits = true; }
    if (mode == 1u) { m.indexBits = 2u; m.chanBits = 6u; m.pBits = false; }
    if (mode == 2u) { m.indexBits = 4u; m.chanBits = 7u; m.pBits = true; }
    if (mode == 3u) { m.indexBits = 4u; m.chanBits = 7u; m.pBits = false; }
    if (mode == 4u) { m.indexBits = 5u; m.chanBits = 8u; m.pBits = true; }
    if (mode == 5u) { m.indexBits = 4u; m.chanBits = 6u; m.pBits = true; }
    if (mode == 6u) { m.indexBits = 7u; m.chanBits = 8u; m.pBits = false; m.hasAlpha = true; }
    if (mode == 7u) { m.indexBits = 4u; m.chanBits = 7u; m.pBits = true; m.partitions = 2u; }
    return m;
}

float expand(uint v, uint bits) { return unormN(v, bits); }

uvec3 read_e0(uint b0, uint b1, ModeMeta m) {
    uint R0 = getBits2x(b0, b1, 8u, m.chanBits);
    uint G0 = getBits2x(b0, b1, 8u + m.chanBits, m.chanBits);
    uint B0 = getBits2x(b0, b1, 8u + m.chanBits * 2u, m.chanBits);
    return uvec3(R0, G0, B0);
}
uvec3 read_e1(uint b1, uint b2, ModeMeta m) {
    uint R1 = getBits2x(b1, b2, 0u, m.chanBits);
    uint G1 = getBits2x(b1, b2, m.chanBits, m.chanBits);
    uint B1 = getBits2x(b1, b2, m.chanBits * 2u, m.chanBits);
    return uvec3(R1, G1, B1);
}

vec3 apply_pbits(vec3 c, ModeMeta m) {
    if (!m.pBits) return c;
    return clamp(c + vec3(1.0 / float((1u << m.chanBits) - 1u)), 0.0, 1.0);
}

void main() {
    uint bi = block_index();
    uvec2 origin = block_origin(bi);

    uint b0 = bc_words[bi * 4u + 0u];
    uint b1 = bc_words[bi * 4u + 1u];
    uint b2 = bc_words[bi * 4u + 2u];
    uint b3 = bc_words[bi * 4u + 3u];

    ModeMeta m = meta_from_header(b0);

    // Endpoints
    uvec3 e0u = read_e0(b0, b1, m);
    uvec3 e1u = read_e1(b1, b2, m);

    vec3 E0 = vec3(expand(e0u.x, m.chanBits), expand(e0u.y, m.chanBits), expand(e0u.z, m.chanBits));
    vec3 E1 = vec3(expand(e1u.x, m.chanBits), expand(e1u.y, m.chanBits), expand(e1u.z, m.chanBits));

    E0 = apply_pbits(E0, m);
    E1 = apply_pbits(E1, m);

    // Indices: 16 texels, per-mode bit-size
    uint64_t idx64 = uint64_t(b2) | (uint64_t(b3) << 32);
    uint maxIdx = (1u << m.indexBits) - 1u;

    for (uint t = 0u; t < 16u; ++t) {
        uint idx = uint((idx64 >> (t * m.indexBits)) & maxIdx);
        float w = float(idx) / float(maxIdx);
        vec3 rgb = mix(E0, E1, w);

        uint px = t & 3u, py = t >> 2;
        store_px(ivec2(origin) + ivec2(px, py), vec4(rgb, 1.0));
    }
}
